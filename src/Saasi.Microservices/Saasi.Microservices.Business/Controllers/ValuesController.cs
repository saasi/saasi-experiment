using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using System.Threading;
using Newtonsoft.Json.Serialization;
using Nexogen.Libraries.Metrics.Prometheus;
using Saasi.Shared.Queue;

namespace Saasi.Microservices.Business
{
    [Route("api")]
    public class ValuesController : Controller
    {

        private readonly IMetricsContainer _metrics;
        private readonly IThrottleQueue _tq;
        private readonly IApiCaller _api;

        private readonly TimeSpan[] Timeout = new TimeSpan[]{new TimeSpan(0,0,10), 
                                                             new TimeSpan(0,0,25),
                                                             new TimeSpan(0,0,30),
                                                             new TimeSpan(0,0,20),
                                                             new TimeSpan(0,0,30),
                                                             new TimeSpan(0,0,30)};
        public ValuesController(IMetricsContainer metrics, IThrottleQueue tq, IApiCaller api)
        {
            this._metrics = metrics;
            this._tq = tq;
            this._api = api;
        }

        private void UpdateMetrics() {
            _metrics.GetGauge("bms_in_queue")
                .Labels("1")
                .Value = _tq.ItemsWaiting;
            _metrics.GetGauge("bms_exec")
                .Labels("1")
                .Value = _tq.ItemsRunning;
        }
        // GET api/Business
        [HttpGet("Business")]
        /*
         * io: whether to generate Disk I/O load. (yes if io=1, no if io=0)
         * cpu: whether to generate CPU usage. (yes if cpu=1, no if cpu=0)
         * memory: whether to generate Memory usage. (yes if memory=1, no if memory=0)
         * timestart: the Unix timestamp when the request is sent (generated by the user)
         * timetorun: for how long (in seconds) should we generate the CPU/Memory/IO load?
         * timeout: the maximum time (in seconds) allowed for the request to finish.
         */
        public async Task<ActionResult> SimulateBusinessTransaction(int operationId)
        {
            if (! (operationId>=0 && operationId <=5) ) {
                return new StatusCodeResult(404);
            }
            Guid TranscationID = Guid.NewGuid();
            _metrics.GetGauge("bms_active_transactions")
                .Labels(operationId.ToString())
                .Increment();
            DateTime QueueTime = DateTime.Now;
            Console.WriteLine($"Transcation {TranscationID}: Queued at {QueueTime.ToString()}");
            Task.Factory.StartNew(()=>UpdateMetrics());
            Guid token = await _tq.QueueUp();
            DateTime StartTime = DateTime.Now;
            Console.WriteLine($"Transcation {TranscationID}: Started {StartTime.ToString()}");
            UpdateMetrics();
            Object result = new {};
            try {
                switch (operationId)
                {
                    case 0:
                        result = await Operation0();
                        break;
                    case 1:
                        result = await Operation1();
                        break;
                    case 2:
                        result = await Operation2();
                        break;
                    case 3:
                        result = await Operation3();
                        break;
                    case 4:
                        result = await Operation4();
                        break;
                    case 5:
                        result = await Operation5();
                        break;
                    default:
                        break;
                }

            } catch {
                // do nothing
            }
  

            Console.WriteLine($"Transcation {TranscationID}: Finished at {DateTime.Now.ToString()}");
            _metrics.GetGauge("bms_active_transactions")
                .Labels(operationId.ToString())
                .Decrement();
            var finishedTime = DateTime.Now;
            var violated = false;
            if (finishedTime - QueueTime > this.Timeout[operationId]) {
                Console.WriteLine($"Transcation {TranscationID}: Business violation");            
                _metrics.GetCounter("bms_business_violation_total")
                     .Labels(operationId.ToString())
                    .Increment();
                violated = true;
            } 
            _metrics.GetCounter("bms_requests_served")
                .Labels(operationId.ToString())
                .Increment();
            Task.Factory.StartNew(()=>{ _tq.Finish(token); UpdateMetrics();});
            return new JsonResult(new {
                Result = result,
                QueuedAt = QueueTime.ToString(),
                StartedAt = StartTime.ToString(),
                FinishedAt = finishedTime,
                BusinessViolation = violated
            });
        }

        [HttpGet("status")]
        public string GetStatus() {
            return "OK";
        }

        // sleep 5s
        private async Task<object> Operation0() {
            await Task.Delay(5000);

            return "Slept";
        }
        // par(io(1), cpu(1))  sleep 2s  mem(2)
        private async Task<object> Operation1() {
            var tasks = new List<Task<object>>();
           
            tasks.Add(_api.CallIo(1));
            
            tasks.Add(_api.CallCpu(1));
        
            await Task.WhenAll(tasks.ToArray());

            await Task.Delay(2000);
            
            var resultList = new Dictionary<string, object>();
                //resultList.Add("io", tasks[0].Result.Payload.Length);    
                resultList.Add("cpu", tasks[1].Result);
            {
                var resultMem = await _api.CallMemory(2);
                resultList.Add("memory", resultMem);
            }

            return resultList;
        }

        // cpu(1)  sleep 5s  mem(1) io(1)
        private async Task<object> Operation2() {
            await _api.CallCpu(1);

            await Task.Delay(5000);
            
            var resultList = new Dictionary<string, object>();

            var resultMem = await _api.CallMemory(1);
            resultList.Add("memory", resultMem);
            await _api.CallIo(1);

            return resultList;
        }

        // io(1) sleep 1 mem(3)
        private async Task<object> Operation3() {
            await _api.CallIo(1);
 
            await Task.Delay(1000);
            
            var resultList = new Dictionary<string, object>();

            var resultMem = await _api.CallMemory(3);
            resultList.Add("memory", resultMem);

            return resultList;
        }

         // mem(1) cpu(1)
        private async Task<object> Operation4() {
            var resultList = new Dictionary<string, object>();

            var resultMem = await _api.CallMemory(1);
            resultList.Add("memory", resultMem);
            
            await _api.CallCpu(1);

            return resultList;
        }
        
        // io(1) sleep 1 cpu(3)
        private async Task<object> Operation5() {
            await _api.CallIo(1);
            await Task.Delay(1000);

            await _api.CallCpu(3);

            return "OK";
        }

    }
}
