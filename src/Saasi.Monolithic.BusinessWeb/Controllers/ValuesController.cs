using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using System.Threading;
using Saasi.Shared.Workload;
using Newtonsoft.Json.Serialization;
using Nexogen.Libraries.Metrics.Prometheus;
using Saasi.Shared.Queue;

namespace Saasi.Monolithic.BusinessWeb.Controllers
{
    [Route("api")]
    public class ValuesController : Controller
    {

        private readonly IMetricsContainer _metrics;
        private readonly IThrottleQueue _tq;

        private readonly TimeSpan[] Timeout = new TimeSpan[]{new TimeSpan(0,0,5)};
        public ValuesController(IMetricsContainer metrics, IThrottleQueue tq)
        {
            this._metrics = metrics;
            this._tq = tq;
        }

        // GET api/Business
        [HttpGet("Business")]
        /*
         * io: whether to generate Disk I/O load. (yes if io=1, no if io=0)
         * cpu: whether to generate CPU usage. (yes if cpu=1, no if cpu=0)
         * memory: whether to generate Memory usage. (yes if memory=1, no if memory=0)
         * timestart: the Unix timestamp when the request is sent (generated by the user)
         * timetorun: for how long (in seconds) should we generate the CPU/Memory/IO load?
         * timeout: the maximum time (in seconds) allowed for the request to finish.
         */
        public async Task<ActionResult> SimulateBusinessTransaction(int operationId)
        {
            if (! (operationId>=0 && operationId <=0) ) {
                return new StatusCodeResult(404);
            }
            Guid TranscationID = Guid.NewGuid();
            _metrics.GetGauge("bms_active_transactions")
                .Labels(operationId.ToString())
                .Increment();
            DateTime QueueTime = DateTime.Now;
            Console.WriteLine($"Transcation {TranscationID}: Queued at {QueueTime.ToString()}");

            Guid token = await _tq.QueueUp();
            DateTime StartTime = DateTime.Now;
            Console.WriteLine($"Transcation {TranscationID}: Started {StartTime.ToString()}");
            
            Object result = new {};
            try {
                switch (operationId)
                {
                    case 0:
                        result = await Operation0();
                        break;
                    default:
                        break;
                }

            } catch {
                // do nothing
            }
  

            Console.WriteLine($"Transcation {TranscationID}: Finished at {DateTime.Now.ToString()}");
            _metrics.GetGauge("bms_active_transactions")
                .Labels(operationId.ToString())
                .Decrement();
            _tq.Finish(token);
            var finishedTime = DateTime.Now;
            var violated = false;
            if (finishedTime - QueueTime > this.Timeout[operationId]) {
                Console.WriteLine($"Transcation {TranscationID}: Business violation");            
                _metrics.GetCounter("bms_business_violation_total")
                     .Labels(operationId.ToString())
                    .Increment();
                violated = true;
            } 
            return new JsonResult(new {
                Result = result,
                QueuedAt = QueueTime.ToString(),
                StartedAt = StartTime.ToString(),
                FinishedAt = finishedTime,
                BusinessViolation = violated
            });
        }

        [HttpGet("status")]
        public string GetStatus() {
            return "OK";
        }

        private async Task<object> Operation0() {
            var tasks = new List<Task<ExecutionResult>>();
           
            {
                var ioWorkload = new IoWorkload();
                var r = new Random();
                Int64 startByte = ((long)r.Next(10, 100000000) * (long)r.Next(10, 100000000)) % (Program.cellSize*(Program.cellCount-1L));
                Int64 length = 1L * Program.cellSize;

                tasks.Add(ioWorkload.Run(startByte, length));
            }
            {
                var cpuWorkload = new CpuWorkload();
                tasks.Add(cpuWorkload.Run(1));
            }
            await Task.WhenAll(tasks.ToArray());

            Thread.Sleep(2000);
            
            var resultList = new Dictionary<string, ExecutionResult>();
                resultList.Add("io", tasks[0].Result);    
                resultList.Add("cpu", tasks[1].Result);
            {
                var memoryWorkload = new MemoryWorkload();
                var resultMem = await memoryWorkload.Run(2);
                resultList.Add("memory", resultMem);
            }

            return resultList;
        }

    }
}
